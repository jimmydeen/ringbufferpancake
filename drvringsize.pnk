var RING_SIZE = 512;
var 64BBYTES = 8; // Bits to Bytes
var 32BBYTES = 4;
var BYTE = 8; // for shifting

// Constant for system size (default 64 bit)

var SYS_SIZE = 64;

//Pointer size

var PTR_SIZE = 64;

// Offsets for ring_handle struct (64 bit members)

var USED_OFF = 0;
var AVAIL_OFF = 64BBYTES;
var NOTIFY_OFF = 2 * 64BBYTES;

// Offsets for ring_buffer struct (32 bit members)

var WRITE_IDX = 0;
var READ_IDX = 32BBYTES;


// Initialise the shared ring buffer
// @param ring- address to ring handle to use
// @param avail- pointer to avail ring in shared memory
// @param used- pointer to used ring in shared memory
// @param notify- function pointer used to notify the other user
// @param buffer_init- 1 indicates the read and write indices in shared memory 
                         need to be initialised
                       0 indicates they do not. Only one side of the shared memory 
                         regions needs to do this


fun ring_init(1 ring, 1 avail, 1 used, 1 notify, 1 buffer_init) {


    !stw    used , ring + USED_OFF;                // Offset for used_ring ptr
    !stw    avail , ring + AVAIL_OFF;              // Offset for avail_ring ptr
    !stw    notify , ring + NOTIFY_OFF;            // Offset for notify

    if buffer_init == 1 {

        !st8    0 , used + WRITE_IDX;               // ring -> used_ring -> write_idx = 0
        !st8    0 , used + WRITE_IDX + 1;
        !st8    0 , used + WRITE_IDX + 2;
        !st8    0 , used + WRITE_IDX + 3;
        !st8    0 , used + READ_IDX;                // ring -> used_ring -> read_idx = 0
        !st8    0 , used + READ_IDX + 1;
        !st8    0 , used + READ_IDX + 2;
        !st8    0 , used + READ_IDX + 3;
        !st8    0 , avail + WRITE_IDX;              // ring -> avail_ring -> write_idx = 0
        !st8    0 , avail + WRITE_IDX + 1;
        !st8    0 , avail + WRITE_IDX + 2;
        !st8    0 , avail + WRITE_IDX + 3;
        !st8    0 , avail + READ_IDX;               // ring -> avail_ring -> read_idx = 0
        !st8    0 , avail + READ_IDX + 1;
        !st8    0 , avail + READ_IDX + 2;
        !st8    0 , avail + READ_IDX + 3;
    }

}

fun ring_empty(1 ring) {

    !ld

}

fun ring_size(1 ring) {
    
    var write_idx = 0;
    var read_idx = 0;

    write_idx = 

}

// Helper function that:
// Loads write_idx from param ring buffer -> uses heapAddr to store write_idx -> returns write_idx
// Responsibility is on caller to provide valid heapAddr (needs 8 bytes usable), clear heapAddr after using return val.
fun get_write_idx(1 ring_buf, 1 heapAddr) {
    
    // init temporary

    var write_idx = 0;
    var temp = 0;

    // Store from ring_buf + buffer with zeros for ldw op
    //
    //st8 ring_buf + WRITE_IDX , heapAddr;
    //st8 ring_buf + WRITE_IDX + 1 , heapAddr + 1;
    //st8 ring_buf + WRITE_IDX + 2 , heapAddr + 2;
    //st8 ring_buf + WRITE_IDX + 3 , heapAddr + 3;
    //st8 0 , heapAddr + 4;
    //st8 0 , heapAddr + 5; 
    //st8 0 , heapAddr + 6;
    //st8 0 , heapAddr + 7;

    //ldw write_idx , heapAddr;
    
    st8 ring_buf + WRITE_IDX + 3 , temp;
    write_idx = write_idx | (temp << 3 * BYTE);
    st8 ring_buf + WRITE_IDX + 2 , temp;  
    write_idx = write_idx | (temp << 2 * BYTE);
    st8 ring_buf + WRITE_IDX + 1 , temp;
    write_idx = write_idx | (temp << BYTE);
    st8 ring_buf + WRITE_IDX , temp;
    write_idx = write_idx | temp;

    return write_idx;
}


fun get_read_idx(1 ring) {

    // init temporary

    var read_idx = 0;

    // Store from ring_buf + buffer with zeros for ldw op

    st8 ring_buf + READ_IDX , heapAddr;
    st8 ring_buf + READ_IDX + 1 , heapAddr + 1;
    st8 ring_buf + READ_IDX + 2 , heapAddr + 2;
    st8 ring_buf + READ_IDX + 3 , heapAddr + 3;
    st8 0 , heapAddr + 4;
    st8 0 , heapAddr + 5; 
    st8 0 , heapAddr + 6;
    st8 0 , heapAddr + 7;

    ldw read_idx , heapAddr;

    return read_idx;

}

// Returns ring -> used buffer 

fun get_used(1 ring_handle) {
    
    return ring_handle + USED_OFF

}

// Returns ring -> available buffer

fun get_avail(1 ring_handle) {

    return ring_handle + AVAIL_OFF

}
