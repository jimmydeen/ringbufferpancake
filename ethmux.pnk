// RUN PREPROCESSOR FIRST BEFORE COMPILING ! (cpp <filename>)

// General macros
#define BBYTES64 8;
#define BBYTES32 4;
#define BYTE 8;

// Offsets for ring_handle struct (64 bit members)

#define USED_OFF 0;
#define AVAIL_OFF BBYTES64;
#define NOTIFY_OFF (2 * BBYTES64);

// Offsets for ring_buffer struct (32 bit members)

#define WRITE_IDX 0;
#define READ_IDX BBYTES32;


// Initialise the shared ring buffer
// @param ring- address to ring handle to use
// @param avail- pointer to avail ring in shared memory
// @param used- pointer to used ring in shared memory
// @param notify- function pointer used to notify the other user
// @param buffer_init- 1 indicates the read and write indices in shared memory 
                    //   need to be initialised
                    // 0 indicates they do not. Only one side of the shared memory 
                    //   regions needs to do this


fun ring_init(1 ring, 1 avail, 1 used, 1 notify, 1 buffer_init) {


    !stw    used , ring + USED_OFF;                // Offset for used_ring ptr
    !stw    avail , ring + AVAIL_OFF;              // Offset for avail_ring ptr
    !stw    notify , ring + NOTIFY_OFF;            // Offset for notify

    if buffer_init == 1 {

        !st8    0 , used + WRITE_IDX;               // ring -> used_ring -> write_idx = 0
        !st8    0 , used + WRITE_IDX + 1;
        !st8    0 , used + WRITE_IDX + 2;
        !st8    0 , used + WRITE_IDX + 3;
        !st8    0 , used + READ_IDX;                // ring -> used_ring -> read_idx = 0
        !st8    0 , used + READ_IDX + 1;
        !st8    0 , used + READ_IDX + 2;
        !st8    0 , used + READ_IDX + 3;
        !st8    0 , avail + WRITE_IDX;              // ring -> avail_ring -> write_idx = 0
        !st8    0 , avail + WRITE_IDX + 1;
        !st8    0 , avail + WRITE_IDX + 2;
        !st8    0 , avail + WRITE_IDX + 3;
        !st8    0 , avail + READ_IDX;               // ring -> avail_ring -> read_idx = 0
        !st8    0 , avail + READ_IDX + 1;
        !st8    0 , avail + READ_IDX + 2;
        !st8    0 , avail + READ_IDX + 3;
    }

}

//fun ring_empty(1 ring_buf) {

//    return !(ring_size(ring_buf))

//}

//fun ring_full(1 ring) {

//}

fun ring_size(1 ring_buf) {
    
    var write_idx = 0;
    var read_idx = 0;

    write_idx = get_write_idx(ring_buf);
    read_idx = get_read_idx(ring_buf);

    return write_idx - read_idx;

}

// Helper function that gets the idx of write slot in ring buffer

fun get_write_idx(1 ring_buf) {
    
    // init temporary

    var write_idx = 0;
    var temp = 0;
    
    !st8 ring_buf + WRITE_IDX + 3 , temp;
    write_idx = write_idx | (temp << 24);
    !st8 ring_buf + WRITE_IDX + 2 , temp;  
    write_idx = write_idx | (temp << 16);
    !st8 ring_buf + WRITE_IDX + 1 , temp;
    write_idx = write_idx | (temp << 8);
    !st8 ring_buf + WRITE_IDX , temp;
    write_idx = write_idx | temp;

    return write_idx;
}

// Helper function that gets the idx of read slot in ring buffer

fun get_read_idx(1 read_buf) {

    // init temporary

    var read_idx = 0;
    var temp = 0;
    
    !st8 ring_buf + READ_IDX + 3 , temp;
    read_idx = read_idx | (temp << 24);
    !st8 ring_buf + READ_IDX + 2 , temp;  
    read_idx = read_idx | (temp << 16);
    !st8 ring_buf + READ_IDX + 1 , temp;
    read_idx = read_idx | (temp << 8);
    !st8 ring_buf + READ_IDX , temp;
    read_idx = read_idx | temp;

    return read_idx;
}

// Returns ring -> used buffer 

fun get_used(1 ring_handle) {
    
    return ring_handle + USED_OFF;

}

// Returns ring -> available buffer

fun get_avail(1 ring_handle) {

    return ring_handle + AVAIL_OFF;

}
